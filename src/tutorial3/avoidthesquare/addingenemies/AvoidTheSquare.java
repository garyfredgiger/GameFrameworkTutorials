package tutorial3.avoidthesquare.addingenemies;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.event.KeyEvent;

import game.framework.GameEngine;
import game.framework.entities.Entity2D;
import game.framework.entities.shapes.EntityRectangle;
import game.framework.interfaces.IRender;
import game.framework.primitives.Vector2D;
import game.framework.utilities.GameEngineConstants;
import game.framework.utilities.GameUtility;

/**
 * Tutorial 3: Adding Enemy Entities
 * 
 * The steps for this tutorial are contained in the comments of the other project source files.
 * 
 *   This source file contains tutorial steps 1, 2 and 3.
 *   
 */

public class AvoidTheSquare extends GameEngine
{
  public AvoidTheSquare(IRender renderer)
  {
    super(renderer);
  }

  /*
   * STEP 1: Adding the Speed of the Enemies
   * 
   * a) Since enemies are going to be added to the game, the speed of these enemies needs to be defined. 
   *    Add a variable of type double named ENEMY_SPEED and assign it a value of 75.   
   */
  private final double ENEMY_SPEED = 75;

  private final double PLAYER_SPEED = 100;
  
  // Used to record current state of user input 
  private boolean      keyLeftPressed;
  private boolean      keyRightPressed;
  private boolean      keyUpPressed;
  private boolean      keyDownPressed;

  /*
   * STEP 2: Adding a Method Responsible for Adding New Enemies
   * 
   * a) Add a new method named addRandomEnemy with no parameters and of type void
   * b) Create a new instance of the Entity class and call it enemy.
   * c) Set the type of the new enemy entity to ENEMY using the setEntityType() method. The enumerated type
   *    EntityTypes defined in the class GameEngineConstants defines all of the Entity types. All enemies in 
   *    the game must have its type set to ENEMY from the EntityTypes enumeration in order to successfully 
   *    detect collisions between the player and enemies. Collisions will be covered in a later tutorial.
   * d) A position must be assigned to this enemy. Note that the default position of an entity is (0, 0). Rather than
   *    having all enemy entities start at the same position, it would be nice to have them start at different
   *    positions. For this tutorial a random position will be assigned to each enemy that is created using the method
   *    setPosition(x, y). Given the random number generator in the GameUtility class, generate a random double between 
   *    [0, 1), multiply it by the screen width (in this case DEFAULT_CANVAS_WIDTH defined in GameEngineConstants) 
   *    and assign it as the x component in the setPosition() method. Do the same for the y component, but multiply it
   *    by the screen height. The result will be an x position between [0, DEFAULT_CANVAS_WIDTH) and a y position
   *    between [0, DEFAULT_CANVAS_HEIGHT).
   * e) Next, assign a color to the enemy entity. The default entity color is red, therefore it would be a good idea to
   *    assign the enemies a different color than the player entity color from Tutorial 2. In this case enemies will 
   *    be assigned the color blue.
   * f) Next, assign the enemy entity a velocity. Again we will generate a random velocity and assign it to the entity.
   *    To do this we will first need to generate a random velocity. As luck would have it, there is a method in the 
   *    GameUtility class called computeRandomVelocity() that returns a Vector2D where both the x and y component lie in
   *    the interval [0, 1). Create a Vector2D variable named velocity and assign it a random velocity using the method
   *    computeRandomVelocity(). Next, call the method scaleThisVector() in the velocity object and pass it the constant
   *    ENEMY_SPEED that we previously defined in SETP 1 of this tutorial. (NOTE: You do not needs to scale the velocity, 
   *    but given that the random velocity generated by the method computeRandomVelocity() sets both of its x-y components
   *    to values between [0, 1), it will move very slowly across the screen, even at a frame rate of 100 fps.) After 
   *    scaling the velocity, it can be assigned to the enemy entity using the method setVelocity(). 
   * g) All that is left to do is add the newly created enemy entity to the enemy entity list in the game engine. This can
   *    be done by accessing the enemy entity list using the method getEnemies() then calling the add method (e.g., 
   *    getEnemies().add(enemy)). Now each time the method addRandomEnemy is called, a new enemy entity will be added to the enemy 
   *    entity list in the game engine with a random position and velocity.
   * h) An alternate way to add entities to their respective lists is to use the methods below. 
   * 
   *      public void addEnemy(Entity entity)
   *      public void addPlayerShot(Entity entity)
   *      public void addEnemyShot(Entity entity)
   *      
   *    If these methods are used there is no need to explicitly set the entity type as mentioned in step 2c. In this example
   *    the addEnemy() method will be called instead of the original method getEnemies().add(enemy). The new code for the method 
   *    will then become in the method body will then become. 
   *    
   *      Entity enemy = new Entity();
   *      enemy.setPosition(GameUtility.random.nextDouble() * GameEngineConstants.DEFAULT_CANVAS_WIDTH, GameUtility.random.nextDouble() * GameEngineConstants.DEFAULT_CANVAS_HEIGHT);
   *      enemy.setColor(Color.BLUE);
   *
   *      Vector2D velocity = GameUtility.computeRandomVelocity();
   *      velocity.scaleThisVector(ENEMY_SPEED);
   *      enemy.setVelocity(velocity);
   *
   *      addEnemy(enemy);
   */
  public void addRandomEnemy()
  {
    EntityRectangle enemy = new EntityRectangle();
    enemy.setEntityType(GameEngineConstants.EntityTypes.ENEMY);
    enemy.setPosition(GameUtility.random.nextDouble() * GameEngineConstants.DEFAULT_CANVAS_WIDTH, GameUtility.random.nextDouble() * GameEngineConstants.DEFAULT_CANVAS_HEIGHT);
    enemy.setColor(Color.BLUE);

    Vector2D velocity = GameUtility.computeRandomVelocity();
    velocity.scaleThisVector(ENEMY_SPEED);
    enemy.setVelocity(velocity);

    getEnemies().add(enemy);
  }
  
  /*
   * STEP 3: Calling the addRandomEnemy() method.
   * 
   * a) Add a call for the new method from STEP 2 to the method body userGameInit(). When this method is called by the game 
   *    engine, it will call the method addRandomEnemy() and one enemy will be added to the enemy list to be displayed.
   * b) Build this project and run it. The game screen should start displaying the player entity (a red square) and an enemy
   *    square (a blue square) moving in a random direction.
   *    
   * NOTE: You can move your square and collide with the enemy square, but nothing seems to happen. The game engine detects the
   *       collision, but there is no logic in place to handle the collision between the player and enemy. To better understand
   *       this add the following line below to the method public void userHandleEntityCollision(Entity entity1, Entity entity2),
   *       which is located near the bottom of this file.
   *       
   *       System.out.println("A collision occured!");
   *
   *       Re-run the game and now when the player collides with the enemy square, the message "A collision occurred!" should be
   *       displayed one or more times in the Eclispe Console window. It is in the method userHandleEntityCollision(Entity entity1, 
   *       Entity entity2) where collisions are handled between the different entities. This is why each entity needs to be assigned 
   *       a type (as shown in step 3c) so the types of each entity (entity1 and entity2) can be compared with one another to see if 
   *       any processing should occur (e.g., if entity1 has type PLAYER and entity2 has type ENEMY, then mark both as killed). More
   *       about collisions will take place in the next tutorial. 
   *          
   */
  public void userGameInit()
  {
    EntityRectangle player = new EntityRectangle(GameEngineConstants.EntityTypes.PLAYER, 16, 16);
    player.setPosition(GameEngineConstants.DEFAULT_CANVAS_WIDTH/2, GameEngineConstants.DEFAULT_CANVAS_HEIGHT/2);
    this.setNewPlayerEntity(player);

    keyLeftPressed = false;
    keyRightPressed = false;
    keyUpPressed = false;
    keyDownPressed = false;
    
    addRandomEnemy();
  }

  public void userGameStart()
  {}

  public void userGameShutdown()
  {}

  public void userProcessInput()
  {
    double deltaX = 0;
    double deltaY = 0;

    if (keyLeftPressed)
    {
      deltaX -= PLAYER_SPEED;
    }

    if (keyRightPressed)
    {
      deltaX += PLAYER_SPEED;
    }

    if (keyUpPressed)
    {
      deltaY -= PLAYER_SPEED;
    }

    if (keyDownPressed)
    {
      deltaY += PLAYER_SPEED;
    }

    getPlayer().setVelocity(deltaX, deltaY);
  }

  public void gameKeyPressed(int keyCode)
  {
    //System.out.println("gameKeyPressed: " + keyCode);
    switch (keyCode)
    {
      case KeyEvent.VK_UP:
        keyUpPressed = true;
        break;

      case KeyEvent.VK_DOWN:
        keyDownPressed = true;
        break;

      case KeyEvent.VK_LEFT:
        keyLeftPressed = true;
        break;

      case KeyEvent.VK_RIGHT:
        keyRightPressed = true;
        break;
    }
  }

  public void gameKeyReleased(int keyCode)
  {
    switch (keyCode)
    {
      case KeyEvent.VK_UP:
        keyUpPressed = false;
        break;

      case KeyEvent.VK_DOWN:
        keyDownPressed = false;
        break;

      case KeyEvent.VK_LEFT:
        keyLeftPressed = false;
        break;

      case KeyEvent.VK_RIGHT:
        keyRightPressed = false;
        break;
    }
  }

  public void gameKeyTyped(int keyCode)
  {}

  @Override
  public void userHandleEntityCollision(Entity2D entity1, Entity2D entity2)
  {
    /*
     * The line added as instructed in the discussion about collisions from STEP 3.
     */
    System.out.println("A collision occured!");
  }

  @Override
  public void userGameUpdateEntity(Entity2D entity)
  {
    if (!entity.isAlive())
    {
      return;
    }

    GameUtility.warp(entity, screenWidth, screenHeight);
  }

  @Override
  public void userGamePreUpdate()
  {}

  @Override
  public void userGamePreDraw(Graphics2D g) // Changed from graphics
  {}

  @Override
  public void userGamePostDraw(Graphics2D g) // Changed from graphics
  {}
}
